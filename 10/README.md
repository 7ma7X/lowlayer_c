## ディレクトリの内容を読む

ディレクトリはファイル1つ1つの情報を表す構造体の列  
ディレクトリの中身を表現するために使われる構造体を**ディレクトリエントリ**と呼ぶ

#### opendir(3)

パスにあるディレクトリを読み DIR型 というポインタに保存

#### readdir(3)

ディレクトリストリームからエントリを1つ読み struct dirent (DIRectory ENTry) で返す

#### closedir(3)

ディレクトリストリームを閉じる

## ディレクトリの作成

#### mkdir(2)

ディレクトリ path を作成する  
失敗原因が色々ある

- ENOENT（親ディレクトリがない）
- ENOTDIR（親ディレクトリに当たる部分がディレクトリではなかった）
- EEXIST（既にファイルやディレクトリが存在する）
- EPERM（親ディレクトリを変更する権限がない）

#### umask

mkdir() と open() は作成するファイルのパーミッションを指定するが、どちらの場合でも、渡した値がそのまま使われるわけではなく、umask を通じて変更された値が使われる  
一般的なのは umask = 022 で、この値が mode から引き落とされる

#### umask(2)

umask の値を変更する

## ディレクトリの削除

#### rmdir(2)

ディレクトリ path を削除する  
空のディレクトリしか消せない

## ハードリンク

1つのファイルに2つ以上の名前をつけることができる  
`rm` が消すのは実はファイルの実体ではなくファイル名（実体に対応する名前が無くなってはじめて実態も消える）

#### link(2)

ハードリンクを作成するシステムコール

## シンボリックリンク

ハードリンクが名前に実体を結びつけるのに対して、シンボリックリンクは名前に名前を結びつけ、シンボリックリンクにアクセスがあったときに初めて実体を探索する
  
すなわち、ハードリンクとの違いとしては

- 対応する実体が存在しなくてもよい
- ファイルシステムをまたいで別名を付けられる
- ディレクトリにも別名が付けられる

#### symlink(2)

シンボリックリンクを作成

#### readlink(2)

シンボリックリンクの指す名前を得ることができる

## ファイルの削除

#### unlink(2)

名前 path を消す  
ディレクトリを消すことはできない

## ファイルの移動

#### rename(2)

## ファイルの付帯情報を得る

ファイルシステムには、データ本体以外に

- ファイルの種類
- サイズ
- パーミッション
- 所有者
- グループ
- 作成時刻
- 変更時刻
- アクセス時刻

が含まれる。これらを得たい

#### stat(2)

path で表されるエントリの情報を取得し、bufに書き込む

#### lstat(2)

stat() と異なり、シンボリックリンクの場合はリンクをたどらずそのリンク自身の情報を返す

## ファイルの付帯情報の変更

#### chmod(2)

path のモードを mode に変更する

mode の値は以下を足し合わせる

|値|意味|
|---|---|
|400|所有ユーザから読み込み可能|
|200|所有ユーザから書き込み可能|
|100|所有ユーザから実行可能|
|040|所有グループから読み込み可能|
|020|所有グループから書き込み可能|
|010|所有グループから実行可能|
|004|それ以外のユーザから読み込み可能|
|002|それ以外のユーザから書き込み可能|
|001|それ以外のユーザから実行可能|

#### chown(2), lchown(2)

path の所有者を owner に、グループを group に  
chown()の場合はシンボリックリンクの指すファイルに対して変更、lchown() の場合はシンボリックリンク自体に対して変更

#### utime(2)

最終アクセス時刻と最終更新時刻を変更

