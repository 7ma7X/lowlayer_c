## プロセス

#### マルチタスク

プロセスは複数同時に動作できる  
複数のCPUとメモリが存在するように見せかける（仮想CPU、仮想メモリ）

#### 仮想CPU

CPUは非常に短い時間単位で実行プロセスを切り替えている  
この、プロセスのために配分される時間を **タイムスライス** と呼ぶ  
プロセスにいつタイムスライスを与えるかを管理するカーネルの機構が **スケジューラ（ディスパッチャ）**

#### 仮想メモリ

各プロセスに用意されるメモリ全体を **アドレス空間** と呼ぶ  
アドレス空間は 4KB, 8KB などといったサイズの **ページ** に分割され、プロセスから見えるアドレス（論理アドレス）、実際のアドレス（物理アドレス）が対応づけられる  

#### ページング

HDD や SSD などのストレージを物理メモリの代わりに使う  
物理メモリが足りなくなったら、あまり使われていないページをストレージに記録し、論理アドレスとの対応を解除する。そしてプロセスがそのページをアクセスしたら、その瞬間にカーネルがプロセスを停止し、ストレージからページを読み込み、また論理アドレスに対応づけてプロセスを再開する

#### メモリマップトファイル

ファイルをメモリとしてアクセスできるようにする  
ファイルの様々な箇所に断続的にアクセスするコードを単純化できる

#### 共有メモリ

特定範囲の物理メモリを複数プロセスで共有する

## アドレス空間の構造

- テキスト領域（機械語のプログラム）
- データ領域（グローバル変数、static 変数のうち初期化済のもの、文字列リテラルなど）
- BSS 領域（グローバル変数、static 変数のうち初期化が必要ないもの）
- ヒープ領域（malloc() が管理する領域）
- スタック領域（関数呼び出しに伴って必要になるデータを置く領域）

プロセスID が n のプロセスのメモリ配置を確認したいときは `cat /proc/n/maps` を実行すればよい

## メモリ管理にかかわるAPI

- **静的** なメモリ割り当て: グローバル変数やスタティック変数など、ビルド時にメモリを確保する方法
- **動的** なメモリ割り当て: malloc() など

#### malloc(3)

メモリをヒープに割り当てる  
割り当てられたメモリがどうなっているか不明

#### calloc(3)

メモリをヒープに割り当てる  
割り当てられたメモリはゼロクリアされていることが保証

#### realloc(3)

割り当てられたメモリのサイズを拡張または縮小

#### free(3)

割り当てられたメモリを解放

#### brk(2)

まだ物理アドレスが割り当てられていないページに物理アドレスを対応させる

## プログラム生成過程

#### プリプロセス

`#include` などを処理して純粋なC言語を得る

#### コンパイル

C言語をアセンブリ言語に変換する

#### アセンブル

アセンブリ言語を、機械語を含むオブジェクトファイル（*.o）に変換する

#### リンク

オブジェクトファイルを実行ファイルまたはライブラリ（*.a, *.so）に変換する  

- **静的ライブラリ（*.a）** スタティックリンクに使うライブラリ。たくさんのオブジェクトファイルが収められていて、スタティックリンクによって生成されるプログラムに物理的に連結される。すなわち静的ライブラリはビルド時にあればよい

- **共有ライブラリ（*.so）** ダイナミックリンクに使うライブラリ。全体が1つのオブジェクトファイルとして構成される。ダイナミックリンクによって、実行時に **リンクローダ** が実行ファイルと共有ライブラリをメモリに展開し、メモリの上で最終的にコードを結合する。すなわちビルド時だけでなく実行時にも必要

**常にダイナミックリンクを使うべき**
  
例えば `libm.so` をダイナミックリンクしたいときは、ファイル名の先頭の `lib` をとりのぞいて `-lm` と指定する。すなわち

```
gcc calc.c -lm -o calc
```

#### ダイナミックロード

ライブラリの利用を実行時のみでやっていく `dlopen()`