#### ストリームに関わるライブラリ

システムコールを直接使ってストリームを扱う欠点

- バイト数単位でしか読み書きができないので不便
- 関数呼び出しに比べてシステムコール呼び出しは遅い

→ 標準入出力ライブラリ `stdio` が開発される

#### stdio の特徴

独自の**バッファ**を用意  
バッファを経由してデータをやり取りする（バッファリング）  

読みの場合:  
バッファから必要な分だけ取ってくる

書きの場合:  
バッファが一杯になったら書き出す  
例外
- 改行が書き込まれたら即座に出力
- アンバッファードモードの場合一切バッファリングされない
- stderr

#### FILE 型

システムコールレベルではファイル記述子という整数値を用いるが, stdio では FILE という型へのポインタを使う

#### fopen(3)

open()に対応するAPI  
標準入出力以外のストリームに対応する FILE を得る  
モードが色々ある http://www.c-tipsref.com/reference/stdio/fopen.html

#### fclose(3)

close()に対応するAPI  

## バイト単位の入出力

#### fgetc(3), fputc(3)

バイト単位での入出力API  マクロ版 getc(3), putc(3)

#### getchar(3), putchar(3)

入力元・出力先が固定されている  
getchar() = getc(stdin)  
putchar(c) = putc(c, stdout)

#### ungetc(3)

1バイトをバッファに戻す

## 行単位の入出力, フォーマット付き入出力

#### fgets(3)

ストリームから1行読み込んでバッファに格納  
ちゃんと1行読み込んだのか、バッファ上限一杯に書き込んで止まったのか区別できない  
ちなみにgets()にはバッファの上限がなく、バッファの範囲を超えて書き込まれうるので絶対に使っちゃダメ

#### fputs(3)

任意の文字列（行とは限らない）を出力

#### puts(3)

fputs()との違いは、出力が標準出力に制限されていること、末尾に\nがつくこと

#### printf(3), fprintf(3)

フォーマットを指定して出力  
printf の第1引数には文字列リテラルのみ使うべき（バッファなどを直接引数にした時、その中に `%` のような記号が含まれているとバッファーを超えて読み取ろうとするので危険）

#### scanf(3)

フォーマットを指定して入力（これも本当は危険）

## 固定長の入出力

#### fread(3)

ストリームから最大 size * nmemb バイトのデータを読み込む

#### fwrite(3)

ストリームへ最大 size * nmemb バイトのデータを書き込む

## ファイルオフセットの操作

ファイルオフセットとは（復習）・・・ストリームがファイルとつながっている位置

#### fseek(3), fseeko(3)

ファイルオフセットの位置を移動する 仕組みは lseek(2) と同様  
fseek()が32ビット対応、fseeko()が64ビット対応

#### ftell(3), ftello(3)

オフセットの値を返す

#### rewind(3)

オフセットをファイル先頭に巻き戻す

## その他

#### fileno(3)

FILEがラップしているファイル記述子の値

#### fdopen(3)

ファイル記述子をラップする FILE 型の値を新しく作成

#### fflush(3)

ファイルがバッファリングしている内容を即座に write() させる

#### setvbuf(3)

用意したバッファを強制的に使わせる

#### feof(3)

ストリームのEOFフラグを取得

#### ferror(3)

ストリームのエラーフラグを取得

#### clearerr(3)

エラーフラグとEOFフラグをクリア

## システムコールの確認

`strace`