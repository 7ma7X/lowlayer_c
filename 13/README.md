## シグナル

ユーザ（端末）やカーネルがプロセスに何かを通知する目的で使われる。実体としてはint型の整数。

シグナルがプロセスに配送されると以下のいずれかが行われる。

1. 無視する
2. プロセスを終了する
3. プロセスのコアダンプを作成して異常終了する

なお、**コアダンプ**とはプロセスのメモリのスナップショットのこと。

よく使われるシグナル

| シグナル名 | デフォルトの挙動 | 生成原因・用途 |
| -------- | ------------- | ------------- |
| SIGINT | 終了 | 割り込み。プログラムの終了で使う。主に Ctrl + C で生成 |
| SIGHUP | 終了 | ユーザのログアウト |
| SIGPIPE | 終了 | 切れたパイプへの書き込み |
| SIGTERM | 終了 | プロセスの終了で使う |
| SIGKILL | 終了 | 確実にプロセスを終了するために使う。捕捉不可 |
| SIGCHLD | 無視 | 子プロセスの終了または停止 |
| SIGSEGV | コアダンプ | アクセスが禁止されているメモリへのアクセス |
| SIGBUS | コアダンプ | アラインメント違反 |
| SIGFPE | コアダンプ | 算術演算でのエラー |

## シグナルの捕捉

#### signal(2)

シグナル番号 sig のシグナルを受けた時の挙動を変更する。  
具体的には、第二引数 func の関数（ **シグナルハンドラ** ）を呼ぶように変更する。  
signal(2) の実装にはいくつかの問題点がある。

- OSによってはシグナルハンドラ起動後にハンドラの設定を元に戻してしまう。
- システムコール中のシグナルに対する挙動もOSによって異なる。
- 重複して呼び出せない。
- シグナルハンドラ実行中に新たに飛ぶシグナルをブロックする設定ができない。

よって以下の sigaction(2) が作られた

#### sigaction(2)

- OS にかかわらずシグナルハンドラの設定を保持し続けることが保証されている
- システムコールを再起動できる
- シグナルのブロック設定ができる

使用例

```c
#include <signal.h>

typedef void (*sighandler_t)(int);

sighandler_t trap_signal(int sig, sighandler_t handler) {
  struct sigaction act, old;

  act.sa_handler = handler; // シグナルハンドラのセット
  sigemptyset(&act.sa_mask); // sa_mask（ブロックするシグナル）を空にする
  act.sa_flags = SA_RESTART; // システムコールを自動的に再起動する

  if (sigaction(sig, &act, &old) < 0)
    return NULL;

  return old.sa_handler;
}
```

## シグナルの送信

シグナルはカーネルやユーザが送信するものなので、普通プログラムで送る必要は無いが...

#### kill(2)

シグナルを送信するシステムコール

## 端末ドライバのモード

普通は **cookedモード** になっている。`stty -a` で確認

ex) Ctrl + C が端末で動作するプロセスを止める仕組み

1. シェルがパイプを構成するプロセスを fork() する
2. シェルがパイプのプロセスグループIDを tcsetpgrp() で端末に通知する
3. fork された各プロセスがそれぞれのコマンドを exec する
4. Ctrl + C が押される
5. カーネル内の端末ドライバがそれを SIGINT に変換、動作中のプロセスグループに発送
6. プロセスグループがデフォルトの動作にしたがって終了